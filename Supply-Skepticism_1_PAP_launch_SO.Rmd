---
title: "Supply Skepticism 1 -- PAP -- Launched (SO vers.)"
author: "Clayton Nall, Chris Elmendorf, Stan Oklobdzija"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
    number_sections: true
    bibliography: "`r here::here('bib', 'all.bib')`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(tidyverse)
library(gtsummary)
library(ordinal)
library(checkpoint)
library(here)
library(gtools)
library(tidymodels)
library(readxl)
library(corrr)
library(quanteda)
library(quanteda.textplots)
library(quanteda.textstats)
library(naniar)
library(stm)
library(estimatr)
library(gmodels)
library(modelsummary)
library(janitor)
options(dplyr.width=Inf)
# checkpoint(snapshot_date = "2022-02-28", R.version = "4.1.2")
# theme_gtsummary_journal("jama") # formats confidence intervals in tables

```



# Introduction {#intro}

Economists regard high housing prices and the attendant displacement of low-income tenants to be a consequence of inadequate supply. However, some interest groups and policy makers take the position that additional supply wouldn't make a difference. They favor price controls and increased funding for deed-restricted affordable housing, but not relaxation of regulatory barriers to market-rate housing. This “supply skeptical” position [@BeeGouOre19] is reflected in local inclusionary-zoning requirements; in state laws that tie density bonuses to the provision of deed-restricted affordable housing; and in state laws that require cities to plan for “affordable housing” but without accounting for the indirect effect of new market rate housing, or its absence, on the availability of older, relatively inexpensive market-rate units elsewhere in the region.


To date, there is no evidence about whether supply-skepticism is purely an interest-group phenomenon or whether it is reinforced by public opinion. Nor is it known whether mass opinion would be responsive to information about housing market dynamics. If supply-skepticism represents a response from elected officials to sincere beliefs and preferences held by their constituents, the path to housing policy reform involves the considerably difficult task of shifting mass opinion. However, if elites hold differing preferences from voters at-large, then reformers seeking to change housing policy in supply-constrained metros have a considerably easier task of highlighting this disconnect to voters before they go to the polls. 


<!--I reframed this part above: If supply-skepticism were just an elite phenomenon, then the remedy for it is probably an education campaign oriented toward foundations and other sources of financial support for nonprofits advocacy groups. If it’s a mass phenomenon, then an effective remedy may need a broader reach.-->

This exploratory study investigates supply skepticism in the mass public in urban and suburban areas using an online survey with embedded rezoning experiments. @BeeGouOre19 [p. 25] define "supply skepticism" as "the disbelief that additional market-rate housing helps make housing more affordable, and indeed a view that it may increase rents and prices." We view the problem through a somewhat broader lens. We seek to understand not only whether people believe that an exogenous increase to the supply of market-rate housing would make housing more affordable in general, but also: 

1. Are "housing costs," "rent burden" and similar concepts front of mind when respondents are asked to think about the regulation of land-use and housing by local governments? 

1. Do respondents underestimate the effect of new market-rate housing on the availability of more affordable units in the metro region (relative to economists' estimate of this effect)?

1. Are respondents' expectations about the price and quantity effects of a posited upzoning scenario "directionally sensible," in the sense (a) that experimental manipulation of the geographic reach of an upzoning scenario (neighborhood-only, citywide, or statewide) results in larger predicted effects when the geographic scale is larger, and (b) that respondents in high-price housing markets expect larger price and quantity effects than respondents in low-price housing markets.

1. Do respondents predict that a posited upzoning scenario would affect rents and prices in their neighborhood differently than rents citywide? 

1. Is "price skepticism" about the rezoning scenario (specifically, a prediction that it would not reduce citywide rents) explained by "quantity skepticism" (a prediction that it would not increase the metro area's housing stock)?

We also seek to understand whether supply skepticsm in the housing domain correlates with economic knowledge about the workings of supply and demand for other goods, and whether support for zoning deregulation correlates with support for market-oriented <!--**laissez-faire**--> policies in other domains. 

We report subgroup results for two partitions of the data, based on ex-ante beliefs about who are the natural political allies or opponents of zoning-liberalization advocates. One partition, homeowners vs. renters, is based on an objective conception of interest. The other partition, people who do / don't express a preference for lower housing prices and rents, is based on a subjective conception of interest.

We are particularly curious to see whether homeowners who are "rent-effect skeptics"---that is, who state that increased housing supply or zoning liberalization would not reduce rents---are also skeptics about supply and demand in other domains. If these two forms of skepticsm run together among renters but not among homeowners, then it's a fair inference that homeowners' stated skepticism is either insincere or a rationalization of self interest as others have theorized [e.g. @Fischel2005].
<!-- We also seek to understand whether supply skepticism about the effect of rezoning and supply shocks on rents correlates with general views about economics, preferences for lower housing prices and rents, attachments to the local community, homeownership, and engagement in local politics.  -->

Note that the registered pre-analysis plan, eval = F for code chunks with regression model loops. This is to keep the html outputs succinct. We will include these analyses as part of the study.

# Overview of the Survey {#overview}

The survey opens with some demographic screening questions, followed by three free-response questions about regulation of land use and housing development by local governments. These are patterned on the questions used in Stantcheva's studies of mass opinion on taxation, health policy, and trade [@Stantcheva20; @Stantcheva21]. 

Subjects are then randomly assigned to one of three "gentle density" rezoning scenarios. The rezoning scenarios differ in the geographic scale of the reform: for their neighborhood, for their city, or for their entire state. In all scenarios, the proposal is to increase height limits by 50% and allow duplexes and triplexes in single-family neighborhoods. These reforms are comparable to what governments in California and Oregon, as well as cities like Minneapolis have passed in recent years.


After the scenario has been presented and illustrated, we elicit support / opposition as well as predictions about the effect of the rezoning on:

1. Home prices and rents in the respondent's neighborhood. 

1. Rents citywide.

1. Tail-risk to the market value of the repondent's home (for homeowners) or its rental value (for renters).

1. The size of the housing stock in the metropolitan area.  

Next, respondents are queried about the effect on citywide home prices and rents of a hypothetical ten percent increase in the regional housing stock caused by the removal of development restrictions. <!-- While economists utilizing price data can calculate precise estimates for demand elasticity, it is important to understand heuristic models employed by voters given the myriad political constraints upon housing construction in the United States. -->

<!-- This question allows us to measure the perceived elasticity of demand for housing.  -->

Price questions are posed both in a 5-point ordinal format and in a more time-consuming cardinal, numerical format. We expect some roll-off with the cardinal format, and if substantial rolloff occurs we will treat results based on the ordinal question format as the primary results.

After the rezoning and supply-shock survey blocks, respondents are asked several questions that tap economic policy preferences, as well as knowledge about the workings of free trade and supply and demand. We also elicit predictions of the findings of @Mast21's study on the effect of new market-rate housing on the availability of more affordable units elsewhere in the metro region.

We include a battery of questions designed to measure the strength of respondents' attachment to their local territorial community. We randomize whether this battery is presented immediately before or immediately after the rezoning scenario. 

The survey closes with additional questions about demographics, ideology, and engagement with local politics.


# Load and clean data 


```{r readrecode}
testing<-F # Toggle if you want to add test values

###set path for my local machine

D <- read_csv("/home/somebro/Dropbox/local_ideology/NEO_notebooks/data/neo--supply-skepticism-1/NEO - Supply Skepticism Experiment--Final_March 25, 2022_11.22.csv")[-c(1,2),] 
if(testing){
  D$rent_zip<-as.character(runif(nrow(D), min=200, max=4000))
  D$price_zip<-as.character(runif(nrow(D), min=50000, max=2000000))
  D$rent_city<-as.character(runif(nrow(D), min=200, max=4000))
  D$price_city<-as.character(runif(nrow(D), min=50000, max=2000000))
  }

## CE post PAP. Check for speeders per CN's request
D %>% 
  filter(Finished == "1") %>%
  rename(duration_in_seconds = `Duration (in seconds)`) %>%
  mutate(
    seconds = as.numeric(duration_in_seconds),
    minutes = factor(case_when(
      seconds < 5*60 ~ "Less than 5 min",
      seconds >= 5*60 & seconds < 7*60 ~ "5-7 min",
      seconds >= 7*60 & seconds < 9*60 ~ "7-9 min",
      seconds >= 9*60 & seconds < 11*60 ~ "9-11 min",
      seconds >= 11*60 & seconds < 15*60 ~ "11-15 min",
      seconds >= 15*60 & seconds < 20*60 ~ "15-20 min",
      seconds >= 20*60 ~ "More than 20 min"
    ), levels = c("Less than 5 min","5-7 min","7-9 min","9-11 min","11-15 min","15-20 min","More than 20 min"))
  ) %>% 
  group_by(minutes) %>%
  summarize(n = n())


##This block divides the respondents' cities into rent terciles
# D <- D %>% mutate(rent_tercile = case_when(as.numeric(rent_city) <= quantile(as.numeric(rent_city),.33 ) ~ 1,
#                                              as.numeric(rent_city) >= quantile(as.numeric(rent_city),.66) ~ 3,
#                                              TRUE ~ 2)) 


D<-D[-c(1:20),]

D<-D%>%
  mutate(age.cat=recode(Q6.1,'1'='18-29', '2'='30-44', 
                        '3'='45-64', '4'='65 plus'))%>%
  mutate(male=as.numeric(Q6.2=='1'))

D$race.eth<-NA
D$race.eth[D$Q6.3=="1"]<-"White"
D$race.eth[D$Q6.3=="2"]<-"Black"
D$race.eth[D$Q6.3=="4"]<-"Asian"
## Order is important here; any Hispanic supersedes race.
D$race.eth[grep("3", D$Q6.3)]<-"Hispanic"
D$race.eth[D$Q6.3%in%c("5", "6")]<-"Multi/Other"
D$race.eth[is.na(D$race.eth)]<-"Multi/Other"

D<-D%>%
  mutate(has.ba=as.numeric(Q6.4%in%c('3', '4', '5', '6', '7', '8')))%>%
  mutate(ownhome=as.numeric(Q6.5=='1'))%>%
  mutate(employed.ft=as.numeric(Q6.6=='1'))%>%
  mutate(want.price=recode(Q6.7, '1'='Higher', '2'='Same', '3'='Lower'))%>%
  mutate(student=as.numeric(D$Q6.8%in%c('1', '2', '3')))%>%
  mutate(has.kids=as.numeric(D$Q6.9=='1'))%>%
  mutate(married.partner=as.numeric(D$Q6.10%in%c(3,4)))

D<-D%>%
  mutate(loc.say=as.numeric(Q7.2=='2'))%>%
  mutate(loc.leaders=as.numeric(Q7.3=='2'))%>%
  mutate(wvs.geog.1=recode(Q7.4, '1'='city', '2'='state', '3'='country', '4'='continent', '5'='world'))
D$wvs.geog.2<-NA
D$wvs.geog.2[D$Q7.6=='1'|D$Q7.7=='1'|D$Q7.8=='1'|D$Q7.9=='1']<-'city'
D$wvs.geog.2[D$Q7.5=='1'|D$Q7.7=='2'|D$Q7.8=='2'|D$Q7.9=='2']<-'state'
D$wvs.geog.2[D$Q7.5=='2'|D$Q7.6=='2'|D$Q7.8=='3'|D$Q7.9=='3']<-'country'
D$wvs.geog.2[D$Q7.5=='3'|D$Q7.6=='3'|D$Q7.7=='3'|D$Q7.9=='4']<-'continent'
D$wvs.geog.2[D$Q7.5=='4'|D$Q7.6=='4'|D$Q7.7=='4'|D$Q7.8=='4']<-'world'

## People list city/town as the place they identify with the most.
D$wvs.geog.city<-as.numeric(D$wvs.geog.1=="city")
D$wvs.geog.city.any<-as.numeric(D$wvs.geog.1=='city'|D$wvs.geog.2=='city')
## Constructing the localism scale from localism items.

## Create localism index
##drop NAs in localism questions
loc.pc<-D%>%
  select_if(grepl("loc\\.", names(.))) %>%
  drop_na() %>%
  prcomp()  
## Assign the principal components to the dataset.
pc.x<-as.data.frame(loc.pc$x)
###
names(pc.x)<-paste0("loc.", names(pc.x))
##add NAs for PCs where loc response is NA
D_na <- D %>% filter(is.na(loc.leaders)|is.na(loc.say)) %>%
  select(ResponseId) %>% mutate(PC1=NA)
###
rep_id <- D %>% filter(!is.na(loc.leaders)&!is.na(loc.say)) %>% dplyr::pull(ResponseId)
pc.x <- pc.x %>% mutate(ResponseId= rep_id) %>%
  dplyr::select(1, ResponseId)

##we don't care about dimensions other than the 1st so just drop them.
D <- left_join(D, pc.x, by="ResponseId") %>% left_join(D_na, by="ResponseId") %>%
  mutate(loc.PC1 = ifelse(is.na(PC1),loc.PC1, PC1)) %>%
  select(-c(PC1))

D$loc.tot<-rowMeans(select(D, names(loc.pc$center)))
## This creates two measures of localism:
## loc.PC1 is the first principal component
## loc.tot is a basic additive index of the items in the scale, assembled using ex ante beliefs about item directionality.

## Recode "economic freedom" questions
D<-D%>%
  mutate(free.tradegood=as.numeric(Q37.1==1))%>%
  mutate(free.notradeboard=6-as.numeric(Q37.2))%>% ##Reversing direction so that positive is to oppose wage boards
  mutate(free.charter=6-as.numeric(Q37.3))%>% #Reverse coding so that 5 is most supportive of charters
  mutate(free.privatize=6-as.numeric(Q37.4))%>%
  mutate(free.choice=6-as.numeric(Q37.5))%>%
  mutate(free.rentvoucher=as.numeric(Q37.6=='1'))%>%
  mutate(free.norentcontrol=as.numeric(Q37.7=='2'))

## Create economic freedom index
free.pc<-D%>%
  select_if(grepl("free\\.", names(.)))%>%
  drop_na() %>% 
  prcomp() 
pc.x<-as.data.frame(free.pc$x)
names(pc.x)<-paste0("free.", names(pc.x))
####
D_na <- D %>% filter_at(vars(starts_with("free")), any_vars(is.na(.))) %>%
  select(ResponseId) %>% mutate(PC1=NA)
###
rep_id <- D %>% filter_at(vars(starts_with("free")), all_vars(!is.na(.))) %>% dplyr::pull(ResponseId)
pc.x <- pc.x %>% mutate(ResponseId= rep_id) %>%
  dplyr::select(1, ResponseId)

##we don't care about dimensions other than the 1st so just drop them.
D <- left_join(D, pc.x, by="ResponseId") %>% left_join(D_na, by="ResponseId") %>%
  mutate(free.PC1 = ifelse(is.na(PC1),free.PC1, PC1)) %>%
  select(-c(PC1))

D$free.tot<-rowMeans(select(D, names(free.pc$center)))
## free.PC1 is the first principal component
## econ.tot is a basic additive index of the items in the scale, assembled using ex ante beliefs about item directionality.

## Economic ``knowledge" fields
D<-D%>%
  mutate(know.trade=as.numeric(Q36.1=='2'))%>%
  mutate(know.used=as.numeric(Q36.2=='1'))

## Create knowledge index. 
know.pc<-D%>%
  select_if(grepl("know\\.", names(.)))%>%
  drop_na() %>%
  prcomp()  
pc.x<-as.data.frame(know.pc$x)
names(pc.x)<-paste0("know.", names(pc.x))
####
D_na <- D %>% filter_at(vars(starts_with("know")), any_vars(is.na(.))) %>%
  select(ResponseId) %>% mutate(PC1=NA)
###
rep_id <- D %>% filter_at(vars(starts_with("know")), all_vars(!is.na(.))) %>% dplyr::pull(ResponseId)
pc.x <- pc.x %>% mutate(ResponseId= rep_id) %>%
  dplyr::select(1, ResponseId)

##we don't care about dimensions other than the 1st so just drop them.
D <- left_join(D, pc.x, by="ResponseId") %>% left_join(D_na, by="ResponseId") %>%
  mutate(know.PC1 = ifelse(is.na(PC1),know.PC1, PC1)) %>%
  select(-c(PC1))

D$know.tot<-rowMeans(select(D, names(know.pc$center)))

## Engagement with local politics. 
D<-D%>%
  mutate(engage.votelocal=as.numeric(Q40.4=='1'))%>%
  mutate(engage.candidates=as.numeric(Q40.5))%>%
  mutate(locgov.careissues=as.numeric(Q40.6=='1'))%>%
  mutate(engage.petition=as.numeric(grepl("1", Q40.7)))%>%
  mutate(engage.petition=as.numeric(grepl("1", Q40.7)))%>%
  mutate(engage.nbhdmtg=as.numeric(grepl("2", Q40.7)))%>%
  mutate(engage.hearing=as.numeric(grepl("3", Q40.7)))%>%
  mutate(engage.contact=as.numeric(grepl("4", Q40.7)))%>%
  mutate(engage.count=engage.petition+engage.nbhdmtg+engage.hearing+engage.contact)
  
## Use engage.any or vote local as the primary measure?   
engage.pc<-D%>%
  select(engage.count, engage.votelocal, engage.candidates)%>%
  drop_na() %>%
  prcomp()  
## Assign the principal components to the dataset.
pc.x<-as.data.frame(engage.pc$x)
names(pc.x)<-paste0("engage.", names(pc.x))

####
D_na <- D %>% filter_at(vars(starts_with("engage")), any_vars(is.na(.))) %>%
  select(ResponseId) %>% mutate(PC1=NA)
###
rep_id <- D %>% filter_at(vars(starts_with("engage")), all_vars(!is.na(.))) %>% dplyr::pull(ResponseId)
pc.x <- pc.x %>% mutate(ResponseId= rep_id) %>%
  dplyr::select(1, ResponseId)

##we don't care about dimensions other than the 1st so just drop them.
D <- left_join(D, pc.x, by="ResponseId") %>% left_join(D_na, by="ResponseId") %>%
  mutate(engage.PC1 = ifelse(is.na(PC1),engage.PC1, PC1)) %>%
  select(-c(PC1))

## Text analysis recodes
D<-D%>%
  mutate(landuse.consider=Q8.2)%>%
  mutate(landuse.goals=Q8.3)%>%
  mutate(landuse.problems=Q8.4)

## National political ideology questions 
D<-D%>%
  mutate(libcon=as.numeric(recode(Q40.2, '1'='-1', '2'='0', '3'='1', '4'=NULL))) %>%
  mutate(voted20=as.numeric(Q40.3))%>%
  mutate(pid3.nolean=recode(Q40.8, '1'='dem', '2'='rep', '3'='io', '4'='io'))
D$pid3.wlean<-D$pid3.nolean
D$pid3.wlean[D$Q40.11=='1']<-'dem'
D$pid3.wlean[D$Q40.11=='2']<-'rep'

D <- D %>%
  mutate(
    repub = as.numeric(Q40.10), # 1 = Strong, 2 = Not so strong
    dem = as.numeric(recode(Q40.9, '1'='7', '2'='6')),
    ind = as.numeric(recode(Q40.11, '1'='5', '2'='3', '3'='4')),
    pid7 = coalesce(repub, dem, ind)
  ) %>%
  select(-repub, -dem, -ind)

ideo.pc<-D%>%
  select(libcon, pid7) %>%
  na.omit() %>%
  prcomp()  
pc.x<-as.data.frame(ideo.pc$x)
names(pc.x)<-paste0("ideo.", names(pc.x))
D<-merge(D, pc.x, by = 'row.names', all.x = T) %>%
  select(-Row.names)


## CE: Effect of regional 10% supply shock. Q33.1 is city rento (ordinal), Q33.2 and Q33.3 is city rentc (cardinal). Suggested variable naming covention: $shock10.rento.city, $shock10.rentc.city. Workflow for creating rentc variables is (1) assign value of 0 if Q33.1 == 3; (2) assign values of -0.01, -0.05, -0.10, -0.15, -0.20, -0.25, -0.30, respectively, if Q33.2 == 1, 2..., 7. (3) assign 0.01, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, respectively, if Q33.3 == 1, 2..., 7. 

D<-D%>%
  mutate(
    shock10.rento.city=6-as.numeric(Q33.1),
    shock10.rentc.city.down=recode(Q33.2, '1'=-0.01, '2'=-0.05, '3'=-0.10, '4'=-0.15, '5'=-0.20, '6'=-0.25, '7'=-0.30),
    shock10.rentc.city.up=recode(Q33.3, '1'=0.01, '2'=0.05, '3'=0.10, '4'=0.15, '5'=0.20, '6'=0.25, '7'=0.30)
  )
D$shock10.rentc.city<-NA
D$shock10.rentc.city[D$shock10.rento.city==3]<-0
D$shock10.rentc.city[!is.na(D$shock10.rentc.city.down)]<-D$shock10.rentc.city.down[!is.na(D$shock10.rentc.city.down)]
D$shock10.rentc.city[!is.na(D$shock10.rentc.city.up)]<-D$shock10.rentc.city.up[!is.na(D$shock10.rentc.city.up)]

D<-D%>%
  mutate(
    shock10.priceo.city=6-as.numeric(Q34.1),
    shock10.pricec.city.down=recode(Q34.2, '1'=-0.01, '2'=-0.05, '3'=-0.10, '4'=-0.15, '5'=-0.20, '6'=-0.25, '7'=-0.30),
    shock10.pricec.city.up=recode(Q34.3, '1'=0.01, '2'=0.05, '3'=0.10, '4'=0.15, '5'=0.20, '6'=0.25, '7'=0.30)
  )
D$shock10.pricec.city<-NA
D$shock10.pricec.city[D$shock10.priceo.city==3]<-0
D$shock10.pricec.city[!is.na(D$shock10.pricec.city.down)]<-D$shock10.pricec.city.down[!is.na(D$shock10.pricec.city.down)]
D$shock10.pricec.city[!is.na(D$shock10.pricec.city.up)]<-D$shock10.pricec.city.up[!is.na(D$shock10.pricec.city.up)]

## Effect of rezoning. 
D<-D%>%
  mutate(GD.treat=recode(GD_branch, '1'='neighborhood', '2'='city', '3'='state'))

D$GD.support<-NA

# Support outcome ($GD.support): (Q11.1, Q11.5), (Q19.1, Q19.5), (Q26.1, Q26.5). Here's the coding protocol. For Q11.1, replace value with Q11.5 if Q11.2 != 1. For Q19.1, replace value with Q19.5 if Q19.2 != 2. For 26.1, replace value with Q26.5 if Q26.2 != 3. Consider reversing default Qualtrics coding so that higher values correspond to stronger suppot. 

D <-  D %>% mutate_at(vars(Q11.1,Q11.5, Q19.1,Q19.2,Q19.5, Q26.1, Q26.5), as.numeric) %>%
  mutate(GD.support = case_when(!is.na(Q11.1)& Q11.2 == 1 ~ Q11.1,
                                    !is.na(Q11.1) & Q11.2 != 1 ~ Q11.5,
                                    is.na(Q11.1) &!is.na(Q19.1)& Q19.2==2 ~ Q19.1,
                                    is.na(Q11.1) & !is.na(Q19.1) & Q19.2!=2 ~ Q19.5,
                                    is.na(Q11.1) & is.na(Q19.1) &!is.na(Q26.1)&Q26.2==3  ~ Q26.1,
                                    is.na(Q11.1) &is.na(Q19.1)&!is.na(Q26.1)&Q26.2!=3 ~ Q26.5)) %>%
  mutate(GD.support = 6-as.numeric(GD.support))                                  
  

###This produces 245 NA's. Better code above. 
# D$GD.support[!is.na(D$Q11.1)]<-D$Q11.1[!is.na(D$Q11.1)]
# D$GD.support[D$Q11.2!=1]<-D$Q11.5[D$Q11.2!=1]
# D$GD.support[!is.na(D$Q19.1)]<-D$Q19.1[!is.na(D$Q19.1)]
# D$GD.support[D$Q19.2!=2]<-D$Q19.5[D$Q19.2!=2]
# D$GD.support[!is.na(D$Q26.1)]<-D$Q26.1[!is.na(D$Q26.1)]
# D$GD.support[D$Q26.2!=3]<-D$Q26.5[D$Q26.2!=3]
# D$GD.support<-6-as.numeric(D$GD.support)

# Quantity outcome ($GD.quant): Q17.1, Q24.1, Q31.1 (coalesce into $GD.quant and consider reversing the default Qualtrics coding so that higher values correspond to bigger positive effect on metro housing stock)

D <- D %>% mutate_at(vars(Q17.1,Q24.1, Q31.1), as.numeric) %>%
  mutate(GD.quant = case_when(!is.na(Q17.1) ~ Q17.1,
                                          is.na(Q17.1) & !is.na(Q24.1) ~ Q24.1,
                                          is.na(Q17.1) & is.na(Q24.1) ~ Q31.1)) %>%
  mutate(GD.quant = 6-GD.quant)

###This code is messed up here. It's just inputting Q17.1 not values from 24.1 or 31.1, (metro and state stock.) I fixed it above
# D$GD.quant<-NA
# D$GD.quant[!is.na(D$Q17.1)]<-D$Q17.1[!is.na(D$Q17.1)]
# D$GD.quant[!is.na(D$Q24.1)]<-D$Q17.1[!is.na(D$Q24.1)]
# D$GD.quant[!is.na(D$Q31.1)]<-D$Q17.1[!is.na(D$Q31.1)]
# D$GD.quant<-6-as.numeric(D$GD.quant)

# Nabe home value outcome ($GD.priceo.nabe, $GD.pricec.nabe):  (Q13.1, Q13.2, Q13.3),  (Q20.1, Q20.2, Q20.3), (Q27.1, Q27.2, Q27.3). The X.1 response is ordinal, assign to $GD_priceo.nabe, and reverse code so higher values correspond to higher prices? To create the cardinal variable, follow protocol used to code the $shock10.rentc variables, above.  
 # Nabe rent outcome ($GD.rento.nabe, $GD.rentc.nabe):  (Q14.1, Q14.2, Q14.3),  (Q21.1, Q21.2, Q21.3), (Q28.1, Q28.2, Q28.3). The X.1 response is ordinal, assign to $GD_rento.nabe, and reverse code so higher values correspond to higher prices? To create the cardinal variable, follow protocol used to code the $shock10.rentc variables, above. 
D$GD.pricec.nabe<-D$GD.rentc.nabe<-D$GD.priceo.nabe<-D$GD.rento.nabe<-NA


D <- D %>% mutate_at(vars(Q13.1,Q20.1, Q27.1), as.numeric) %>%
  mutate(GD.priceo.nabe = case_when(!is.na(Q13.1) ~ Q13.1,
                                          is.na(Q13.1) & !is.na(Q20.1) ~ Q20.1,
                                          is.na(Q13.1) & is.na(Q20.1) ~ Q27.1)) %>%
  mutate(GD.priceo.nabe = 6-GD.priceo.nabe)

#Fixing coding 
# D$GD.priceo.nabe[!is.na(D$Q13.1)]<-D$Q13.1[!is.na(D$Q13.1)]
# D$GD.priceo.nabe[!is.na(D$Q20.1)]<-D$Q20.1[!is.na(D$Q20.1)]
# D$GD.priceo.nabe[!is.na(D$Q27.1)]<-D$Q27.1[!is.na(D$Q27.1)]
# D$GD.priceo.name<-6-as.numeric(D$GD.priceo.nabe)



D$GD.pricec.nabe[D$GD.priceo.nabe==3]<-0
D$GD.pricec.nabe.down.1<-recode(D$Q13.2, '1'=-0.01, '2'=-0.05, '3'=-0.10, '4'=-0.15, '5'=-0.20, '6'=-0.25, '7'=-0.30)
D$GD.pricec.nabe.up.1<-recode(D$Q13.3, '1'=0.01, '2'=0.05, '3'=0.10, '4'=0.15, '5'=0.20, '6'=0.25, '7'=0.30)
D$GD.pricec.nabe.down.2<-recode(D$Q20.2, '1'=-0.01, '2'=-0.05, '3'=-0.10, '4'=-0.15, '5'=-0.20, '6'=-0.25, '7'=-0.30)
D$GD.pricec.nabe.up.2<-recode(D$Q20.3, '1'=0.01, '2'=0.05, '3'=0.10, '4'=0.15, '5'=0.20, '6'=0.25, '7'=0.30)
D$GD.pricec.nabe.down.3<-recode(D$Q27.2, '1'=-0.01, '2'=-0.05, '3'=-0.10, '4'=-0.15, '5'=-0.20, '6'=-0.25, '7'=-0.30)
D$GD.pricec.nabe.up.3<-recode(D$Q27.3, '1'=0.01, '2'=0.05, '3'=0.10, '4'=0.15, '5'=0.20, '6'=0.25, '7'=0.30)
D$GD.pricec.nabe[!is.na(D$GD.pricec.nabe.up.1)]<-D$GD.pricec.nabe.up.1[!is.na(D$GD.pricec.nabe.up.1)]
D$GD.pricec.nabe[!is.na(D$GD.pricec.nabe.up.2)]<-D$GD.pricec.nabe.up.2[!is.na(D$GD.pricec.nabe.up.2)]
D$GD.pricec.nabe[!is.na(D$GD.pricec.nabe.up.3)]<-D$GD.pricec.nabe.up.3[!is.na(D$GD.pricec.nabe.up.3)]
D$GD.pricec.nabe[!is.na(D$GD.pricec.nabe.down.1)]<-D$GD.pricec.nabe.down.1[!is.na(D$GD.pricec.nabe.down.1)]
D$GD.pricec.nabe[!is.na(D$GD.pricec.nabe.down.2)]<-D$GD.pricec.nabe.down.2[!is.na(D$GD.pricec.nabe.down.2)]
D$GD.pricec.nabe[!is.na(D$GD.pricec.nabe.down.3)]<-D$GD.pricec.nabe.down.3[!is.na(D$GD.pricec.nabe.down.3)]

D <- D %>% mutate_at(vars(Q14.1,Q21.1, Q28.1), as.numeric) %>%
  mutate(GD.rento.nabe = case_when(!is.na(Q14.1) ~ Q14.1,
                                          is.na(Q14.1) & !is.na(Q21.1) ~ Q21.1,
                                          is.na(Q14.1) & is.na(Q21.1) ~ Q28.1)) %>%
  mutate(GD.rento.nabe = 6-GD.rento.nabe)

###Recoding this variable also for the same reason as the others. 
# D$GD.rento.nabe[!is.na(D$Q14.1)]<-D$Q14.1[!is.na(D$Q14.1)]
# D$GD.rento.nabe[!is.na(D$Q21.1)]<-D$Q21.1[!is.na(D$Q21.1)]
# D$GD.rento.nabe[!is.na(D$Q28.1)]<-D$Q28.1[!is.na(D$Q28.1)]
# D$GD.rento.nabe<-6-as.numeric(D$GD.rento.nabe)




D$GD.rentc.nabe[D$GD.rento.nabe==3]<-0
D$GD.rentc.nabe.down.1<-recode(D$Q14.2, '1'=-0.01, '2'=-0.05, '3'=-0.10, '4'=-0.15, '5'=-0.20, '6'=-0.25, '7'=-0.30)
D$GD.rentc.nabe.up.1<-recode(D$Q14.3, '1'=0.01, '2'=0.05, '3'=0.10, '4'=0.15, '5'=0.20, '6'=0.25, '7'=0.30)
D$GD.rentc.nabe.down.2<-recode(D$Q21.2, '1'=-0.01, '2'=-0.05, '3'=-0.10, '4'=-0.15, '5'=-0.20, '6'=-0.25, '7'=-0.30)
D$GD.rentc.nabe.up.2<-recode(D$Q21.3, '1'=0.01, '2'=0.05, '3'=0.10, '4'=0.15, '5'=0.20, '6'=0.25, '7'=0.30)
D$GD.rentc.nabe.down.3<-recode(D$Q28.2, '1'=-0.01, '2'=-0.05, '3'=-0.10, '4'=-0.15, '5'=-0.20, '6'=-0.25, '7'=-0.30)
D$GD.rentc.nabe.up.3<-recode(D$Q28.3, '1'=0.01, '2'=0.05, '3'=0.10, '4'=0.15, '5'=0.20, '6'=0.25, '7'=0.30)
D$GD.rentc.nabe[!is.na(D$GD.rentc.nabe.up.1)]<-D$GD.rentc.nabe.up.1[!is.na(D$GD.rentc.nabe.up.1)]
D$GD.rentc.nabe[!is.na(D$GD.rentc.nabe.up.2)]<-D$GD.rentc.nabe.up.2[!is.na(D$GD.rentc.nabe.up.2)]
D$GD.rentc.nabe[!is.na(D$GD.rentc.nabe.up.3)]<-D$GD.rentc.nabe.up.3[!is.na(D$GD.rentc.nabe.up.3)]
D$GD.rentc.nabe[!is.na(D$GD.rentc.nabe.down.1)]<-D$GD.rentc.nabe.down.1[!is.na(D$GD.rentc.nabe.down.1)]
D$GD.rentc.nabe[!is.na(D$GD.rentc.nabe.down.2)]<-D$GD.rentc.nabe.down.2[!is.na(D$GD.rentc.nabe.down.2)]
D$GD.rentc.nabe[!is.na(D$GD.rentc.nabe.down.3)]<-D$GD.rentc.nabe.down.3[!is.na(D$GD.rentc.nabe.down.3)]


  # City rent outcome ($GD.rento.city, $GD.rentc.city):  (Q15.1, Q15.2, Q15.3),  (Q22.1, Q22.2, Q22.3), (Q29.1, Q29.2, Q29.3). The X.1 response is ordinal, assign to $GD_rento.city, and reverse code so higher values correspond to higher rents? To create the cardinal variable, follow protocol used to code the $shock10.rentc variables, above.
## Q11.1: duplex/triplex

D <- D %>% mutate_at(vars(Q15.1,Q22.1, Q29.1), as.numeric) %>%
  mutate(GD.rento.city = case_when(!is.na(Q15.1) ~ Q15.1,
                                          is.na(Q15.1) & !is.na(Q22.1) ~ Q22.1,
                                          is.na(Q15.1) & is.na(Q22.1) ~ Q29.1)) %>%
  mutate(GD.rento.city = 6-GD.quant)

##This is also messed up and producing NAs, fixed it above. 
# D$GD.rento.city<-NA
# D$GD.rento.city[!is.na(D$Q15.1)]<-D$Q15.1[!is.na(D$Q15.1)]
# D$GD.rento.city[!is.na(D$Q22.1)]<-D$Q22.1[!is.na(D$Q22.1)]
# D$GD.rento.city[!is.na(D$Q29.1)]<-D$Q29.1[!is.na(D$Q29.1)]
# D$GD.rento.city<-6-as.numeric(D$GD.rento.city)  

###City Rent Percentage Shift

D$GD.rentc.city[D$GD.rento.city==3]<-0
D$GD.rentc.city.down.1<-recode(D$Q15.2, '1'=-0.01, '2'=-0.05, '3'=-0.10, '4'=-0.15, '5'=-0.20, '6'=-0.25, '7'=-0.30)
D$GD.rentc.city.up.1<-recode(D$Q15.3, '1'=0.01, '2'=0.05, '3'=0.10, '4'=0.15, '5'=0.20, '6'=0.25, '7'=0.30)
D$GD.rentc.city.down.2<-recode(D$Q22.2, '1'=-0.01, '2'=-0.05, '3'=-0.10, '4'=-0.15, '5'=-0.20, '6'=-0.25, '7'=-0.30)
D$GD.rentc.city.up.2<-recode(D$Q22.3, '1'=0.01, '2'=0.05, '3'=0.10, '4'=0.15, '5'=0.20, '6'=0.25, '7'=0.30)
D$GD.rentc.city.down.3<-recode(D$Q29.2, '1'=-0.01, '2'=-0.05, '3'=-0.10, '4'=-0.15, '5'=-0.20, '6'=-0.25, '7'=-0.30)
D$GD.rentc.city.up.3<-recode(D$Q29.3, '1'=0.01, '2'=0.05, '3'=0.10, '4'=0.15, '5'=0.20, '6'=0.25, '7'=0.30)
D$GD.rentc.city[!is.na(D$GD.rentc.city.up.1)]<-D$GD.rentc.city.up.1[!is.na(D$GD.rentc.city.up.1)]
D$GD.rentc.city[!is.na(D$GD.rentc.city.up.2)]<-D$GD.rentc.city.up.2[!is.na(D$GD.rentc.city.up.2)]
D$GD.rentc.city[!is.na(D$GD.rentc.city.up.3)]<-D$GD.rentc.city.up.3[!is.na(D$GD.rentc.city.up.3)]
D$GD.rentc.city[!is.na(D$GD.rentc.city.down.1)]<-D$GD.rentc.city.down.1[!is.na(D$GD.rentc.city.down.1)]
D$GD.rentc.city[!is.na(D$GD.rentc.city.down.2)]<-D$GD.rentc.city.down.2[!is.na(D$GD.rentc.city.down.2)]
D$GD.rentc.city[!is.na(D$GD.rentc.city.down.3)]<-D$GD.rentc.city.down.3[!is.na(D$GD.rentc.city.down.3)]

  # Home-value anxiety outcome ($GD.angst.price): Q16.1 Q23.1, Q30.1. Reverse code so that higher values correspond to more anxiety?
  # Rent-value anxiety outcome ($GD.angst.rent): Q16.2 Q23.2, Q30.2. Reverse code so that higher values correspond to more anxiety?

D <- D %>%
  mutate(across(c(Q16.1, Q23.1, Q30.1, Q16.2, Q23.2, Q30.2), as.numeric)) %>%
  mutate(GD.angst.price = 5 - coalesce(Q16.1, Q23.1, Q30.1)) %>%
  mutate(GD.angst.rent = 5 - coalesce(Q16.2, Q23.2, Q30.2)) 

## CE: encode embedded data fields $rent_zip, $price_zip, $price_city.  
D <- D %>%
  mutate(
    rent.zip = parse_number(rent_zip),
    price.zip = parse_number(price_zip),
    rent.city = parse_number(rent_city),
    price.city = parse_number(price_city),
    )

## CE: encode mast responses ($mast.afford, $mast.low): former is Q38.1, latter is Q38.2. Recode $mast.afford and $mast.low as NA if Q39.1 != 1. Q39.1 is attention check to see if respondent read the Mast question. We could throw out all responses from people who fail this check but my vote is to keep them. I'm expecting way more BS on the Mast Qs than the other Qs

D <- D %>% 
  mutate(
    across(starts_with("Q38"), as.numeric),
    mast.afford = Q38.1_10, #CE: FWIW, I don't understand why Qualtrics assigned a suffix to these slider responses, or why the suffix is different for Q38.1 vs. Q38.2
    mast.low = Q38.2_4
  )
D$mast.afford[D$Q39.1 != 1] <- NA 
D$mast.low[D$Q39.1 != 1] <- NA 

## Rename other colums for ease of use

D <- D%>%
  mutate(
    zip = Q1.2,
    educ = as.numeric(Q6.4),
    rent.zip.quintile = quantcut(parse_number(rent_zip), 5),
    rent.city.quintile = quantcut(parse_number(rent_city), 5),
    price.zip.quintile = quantcut(parse_number(price_zip), 5),
    price.city.quintile = quantcut(parse_number(price_city), 5),
    rent.zip.tercile = quantcut(parse_number(rent_zip), 3),
    rent.city.tercile = quantcut(parse_number(rent_city), 3),
    price.zip.tercile = quantcut(parse_number(price_zip), 3),
    price.city.tercile = quantcut(parse_number(price_city), 3),
    want.price2 = factor(want.price, levels = c("Lower", "Same", "Higher")),
    want.price2 = fct_collapse(D$want.price, 
                               Lower = "Lower", Not_lower = c("Higher", "Same")),
    GD.treat = factor(GD.treat, levels = c("neighborhood", "city", "state"))
  )

levels(D$rent.zip.quintile) <- c("rent.zip.q5.1", "rent.zip.q5.2", "rent.zip.q5.3", "rent.zip.q5.4", "rent.zip.q5.5")
levels(D$rent.city.quintile) <- c("rent.city.q5.1", "rent.city.q5.2", "rent.city.q5.3", "rent.city.q5.4", "rent.city.q5.5")
levels(D$price.zip.quintile) <- c("price.zip.q5.1", "price.zip.q5.2", "price.zip.q5.3", "price.zip.q5.4", "price.zip.q5.5")
levels(D$price.city.quintile) <- c("price.city.q5.1", "price.city.q5.2", "price.city.q5.3", "price.city.q5.4", "price.city.q5.5")

levels(D$rent.zip.tercile) <- c("rent.zip.q3.1", "rent.zip.q3.2", "rent.zip.q3.3", "rent.zip.q3.4", "rent.zip.q3.5")
levels(D$rent.city.tercile) <- c("rent.city.q3.1", "rent.city.q3.2", "rent.city.q3.3", "rent.city.q3.4", "rent.city.q3.5")
levels(D$price.zip.tercile) <- c("price.zip.q3.1", "price.zip.q3.2", "price.zip.q3.3", "price.zip.q3.4", "price.zip.q3.5")
levels(D$price.city.tercile) <- c("price.city.q3.1", "price.city.q3.2", "price.city.q3.3", "price.city.q3.4", "price.city.q3.5")
```


## Rolloff on cardinal price and rent Qs. 
Report difference in share of missing responses between cardinal and ordinal versions of each question. 

We will run all analyses on both versions of the price and rent questions Unless rolloff is large, we will treat response encoded as cardinal values as the focal dependent variables.

```{r check rolloff on cardinal price questions}

temp <- naniar::miss_var_summary(
  D %>% select(
    GD.rento.nabe,
    GD.rentc.nabe,
    GD.priceo.nabe,
    GD.pricec.nabe,
    GD.rento.city,
    GD.rentc.city,
    shock10.rento.city,
    shock10.rentc.city,
    shock10.priceo.city,
    shock10.pricec.city)
  )

rolloff <- tibble(
  GD.rent.nabe.diff = temp$pct_miss[temp$variable=="GD.rentc.nabe"] - 
    temp$pct_miss[temp$variable=="GD.rento.nabe"],
  GD.price.nabe.diff = temp$pct_miss[temp$variable=="GD.pricec.nabe"] - 
    temp$pct_miss[temp$variable=="GD.priceo.nabe"],
  GD.rent.city.diff =  temp$pct_miss[temp$variable=="GD.rentc.city"] - 
    temp$pct_miss[temp$variable=="GD.rento.city"],
  shock10.rent.city.diff =  temp$pct_miss[temp$variable=="shock10.rentc.city"] - 
    temp$pct_miss[temp$variable=="shock10.rento.city"],
  shock10.price.city.diff =  temp$pct_miss[temp$variable=="shock10.pricec.city"] - 
    temp$pct_miss[temp$variable=="shock10.priceo.city"]
)

```

# Results 

## Sample summary statistics


```{r summary_stats}

datasummary_crosstab(ownhome ~ want.price,data=D, output="markdown")

```


## Natural language analysis

What do people think about when they're asked to think about "regulation of land use and housing development by local governments?"

Our analysis mirrors @Stantcheva21. We plot word clouds; provide a keyness and keywords analysis; and a topic analysis. Whereas Stantcheva lumps respondents by party identification (Clinton Liberals, Clinton Moderates, Trump Liberals, and Trump Conservatives), we provide an analysis where respondents are also split by attributes that we expect will better capture ideological and interest-based differences with respect to land use. 

The primary splits are:

* doesn't vs. does want prices to be lower (\$want.price2) 

* owner vs. renter (\$ownhome)

For comparison, we also provide a split by national political identity (\$ideo.PC1).

<!--The fake data used to code this preanalysis plan doesn't allow us to customize our wordcloud output since the words are gibberish data and we need to adjust minimum frequencies to keep uncommon words out of the plot. This is something we'd have to take care of after we have real data.-->

```{r nlp, fig.cap="Word Cloud, All Responses."}

set.seed(100)

dfm_responses <- corpus(c(D$landuse.consider,D$landuse.goals,D$landuse.problems)) %>% dfm(remove=stopwords("english"), remove_punct=T) 
##word must appear 5 times. Stantcheva does this.
textplot_wordcloud(dfm_responses, min_count=5, title="FDSFDS")



```

```{r nlp2, fig.cap="Word Cloud, Comparing Responses."}

set.seed(100)

comp_corp <- corpus(c(D$landuse.consider,D$landuse.goals, D$landuse.problems)) 

comp_corp$type <- c(rep("consider",length(D$landuse.consider)), rep("goals", length(D$landuse.goals)), rep("problems",length(D$landuse.problems)))

##word must appear 5 times like Stantcheva
comp_corp %>% tokens(remove_punct = T) %>% tokens_remove(stopwords("english")) %>%
  dfm() %>% dfm_group(groups=type) %>% textplot_wordcloud(comparison = T, min_count=5)

```


```{r nlp3, fig.cap="Keyness Analysis: Those who Want Prices Higher vs. Lower and Renters vs. Owners."}

set.seed(100)

key_analysis <- corpus(c(D$landuse.consider,D$landuse.goals, D$landuse.problems)) 

key_analysis$high_low <- D$want.price2
key_analysis$own_rent=D$ownhome

###There are NAs in the data now, we have to drop them.

key_analysis <- key_analysis %>% corpus_subset(!is.na(high_low)& !is.na(own_rent))

###Those who Want the prices Lower vs those who want it same or higher
key_analysis %>%
  tokens(remove_punct = T) %>% 
  dfm() %>% textstat_keyness(., target = key_analysis$high_low=="Lower") %>% textplot_keyness()


##Owners vs Renters
key_analysis%>%
  tokens(remove_punct = T) %>% 
  dfm() %>% textstat_keyness(., target = key_analysis$own_rent==1) %>% textplot_keyness()

```

```{r nlp4, fig.cap="Topic Analysis: Those who Want Prices Higher vs. Lower and Renters vs. Owners."}

set.seed(100)

comp_corp <- corpus(c(D$landuse.consider,D$landuse.goals, D$landuse.problems)) 

comp_corp$type <- c(rep("consider",length(D$landuse.consider)), rep("goals", length(D$landuse.goals)), rep("problems",length(D$landuse.problems)))

comp_corp$high_low <- rep(D$want.price2,3)
comp_corp$own_rent=rep(D$ownhome,3)

###There are NAs in the data now, we have to drop them.

comp_corp <- comp_corp %>% corpus_subset(!is.na(high_low)& !is.na(own_rent))



###Those who Want the prices Lower vs those who want it same or higher, Land Use questions

question <- c("consider","goals", "problems")

for (i in seq_along(question)){
  corpus_subset(comp_corp, type==question[i]) %>%
  tokens(remove_punct = T) %>% 
  dfm() %>% textstat_keyness(., target = corpus_subset(comp_corp, type==question[i])$high_low=="Lower") %>% textplot_keyness() %>% plot()
}

##Owners vs Renters
for (i in seq_along(question)){
  corpus_subset(comp_corp, type==question[i]) %>%
  tokens(remove_punct = T) %>% 
  dfm() %>% textstat_keyness(., target = corpus_subset(comp_corp, type==question[i])$own_rent==1) %>% textplot_keyness() %>% plot()
}



```


In the SI, we will also provide results for splits on:
* localism (median split on \$loc.PC1)
* respondents binned into terciles by city rent (\$rent.city) 
* engaged or not engaged in local politics (median split on $engage.PC1)
* pro-market or anti-market ideology (median split on $free.PC1)
* econ knowledge (median split $know.PC1)


We also propose a sentiment analysis of respondent answers using a dictionary based approach^[See https://cran.r-project.org/web/packages/SentimentAnalysis/index.html]. Scoring each open-ended text response along a continuous scale of positivity, we can measure correlations between respondent feelings on existing land use policy and the problems with current land use policy. Further, the disposition of their proposed policy solutions, (as measured by question 8.3), would also be instructive. 

```{r nlp_sent_analysis, fig.cap="Sentiment Analysis: Renters vs. Owners."}

##This is the Lexicoder Sentiment Dictionary. 
set.seed(100)

open_end_corp <- corpus(c(D$landuse.consider,D$landuse.goals, D$landuse.problems)) 

open_end_corp$own_rent <- D$ownhome

##Remove NAs

open_end_corp <- open_end_corp %>% corpus_subset(!is.na(own_rent))

pos_neg <- data_dictionary_LSD2015[1:2]

toks_open_end <- tokens(open_end_corp, remove_punct = T)

toks_open_end_sent <- tokens_lookup(toks_open_end, dictionary = pos_neg)

# create a document document-feature matrix and group it by day
dfmat_oe_sent <- dfm(toks_open_end_sent) %>% 
  dfm_group(groups = own_rent)

tibble("own_rent"=c(0,1), "neg"=dfmat_oe_sent@x[1:2], "pos"=dfmat_oe_sent@x[3:4]) %>%
  group_by(own_rent) %>%
  mutate(rel_pos = pos/sum(pos+neg),
         rel_neg = neg/sum(pos+neg)) %>%
  pivot_longer(cols=c(rel_pos, rel_neg)) %>%
  ggplot(aes(x=factor(own_rent), y=value, group=name)) + geom_bar(stat="identity", position="dodge", aes(fill=name)) + scale_x_discrete("",labels=c("Renter","Owner")) +
  scale_fill_discrete("Sentiment",labels=c("Prop. Negativity","Prop. Positivity")) 


```


Finally, we propose a two-pronged topic modeling approach. First, we will utilize the Stochastic Block Model method^[See Gerlach, M., Peixoto, T.P. and Altmann, E.G., 2018. A network approach to topic models. Science advances, 4(7), p.eaaq1360.] to discover themes and topics within respondent answers to the open-ended questions. This method obviates some concerns with traditional Latent Dirichlet Allocation, (LDA), by using community-detection methods borrowed from network science. Next, we will utilize other respondent characteristics such as renter status, income, and political participation to inform topic modeling using the Structural Topic Models approach^[See https://cran.r-project.org/web/packages/stm/].  

<!--**Stochastic Block Modeling can only be done in Python. I can't code it quickly enough for our PAP, so if we need pseudocode for it, I suggest we just drop it for now. STM should be good enough.**-->

```{r nlp_stm, fig.cap="Structural Topic Models"}

set.seed(100)

open_end_corp <- corpus(c(D$landuse.consider,D$landuse.goals, D$landuse.problems)) 

open_end_corp$own_rent <- D$ownhome
open_end_corp$male <- D$male
open_end_corp$employed_ft <- D$employed.ft

oe_dfm <- dfm(open_end_corp, remove_numbers = TRUE, remove_punct = TRUE, remove_symbols = TRUE, remove = stopwords("english"))

###Gotta change the frequency trims
oe_dfm_trim <- dfm_trim(oe_dfm, min_docfreq = 0.01, max_docfreq = 0.99, docfreq_type = "prop") 
topic.count <- 10

dfm2stm <- convert(oe_dfm_trim, to = "stm")

model.stm <- stm(dfm2stm$documents, dfm2stm$vocab, K = topic.count, data = dfm2stm$meta, init.type = "Spectral")

plot(model.stm, type = "summary", text.cex = 0.5)

```




## Anticipated effect of regional supply shock on prices and rents

We consider initially the perceived effect of an exogenous 10% shock to the regional stock of housing, caused by removal of development restrictions, on home price and rents in the respondent's city. <!-- The answer to this question (in the potential outcomes version) can be expressed as the perceived elasticity of demand for housing: (% change in quantity) / (% change in price).  -->

We report differences in means along with 95% confidence intervals for the perceived effect on rent prices, and home values, that a 10% exogenous shock would have in a respondent's city at each tercile of average city home prices. (We will also produce these figures using ordinal versions of the outcome questions.)


```{r results - shock10 - figs1, fig.cap="Perceived Effect on Citywide Rents of 10% Supply Shock"}

D %>%  
  group_by(price.city.tercile) %>%
  summarise(mean=gmodels::ci(shock10.rentc.city,na.rm=T)[1],
            lowCI=gmodels::ci(shock10.rentc.city, na.rm=T)[2],
            highCI=gmodels::ci(shock10.rentc.city, na.rm=T)[3],
            sd=gmodels::ci(shock10.rentc.city, na.rm=T)[4]) %>%
  ggplot(aes(x=price.city.tercile,y=mean)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI), position=position_dodge(width=.5)) +
  ylab("Cardinal Effect on Rents")+
  ggtitle("Full Sample") +
  theme(legend.positio="bottom")

D %>% #filter(GG.mppcr >1) %>% 
  group_by(price.city.tercile, ownhome) %>%
  summarise(mean=gmodels::ci(shock10.rentc.city,na.rm=T)[1],
            lowCI=gmodels::ci(shock10.rentc.city, na.rm=T)[2],
            highCI=gmodels::ci(shock10.rentc.city, na.rm=T)[3],
            sd=gmodels::ci(shock10.rentc.city, na.rm=T)[4]) %>%
  ggplot(aes(x=price.city.tercile,y=mean,group=ownhome)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI, color=factor(ownhome)), position=position_dodge(width=.5)) +
  ylab("Cardinal Effect on Rents")+
  ggtitle("Owners vs. Renters") +
  theme(legend.positio="bottom")

D %>% #filter(GG.mppcr >1) %>% 
  group_by(price.city.tercile, want.price2) %>%
  summarise(mean=gmodels::ci(shock10.rentc.city,na.rm=T)[1],
            lowCI=gmodels::ci(shock10.rentc.city, na.rm=T)[2],
            highCI=gmodels::ci(shock10.rentc.city, na.rm=T)[3],
            sd=gmodels::ci(shock10.rentc.city, na.rm=T)[4]) %>%
  ggplot(aes(x=price.city.tercile,y=mean,group=want.price2)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI, color=factor(want.price2)), position=position_dodge(width=.5)) +
  ylab("Cardinal Effect on Rents")+
  ggtitle("Those Who Want Prices Lower vs. Higher") +
  theme(legend.positio="bottom")

```


```{r results - shock10 - figs2, fig.cap="Perceived Effect on Citywide Home Values of 10% Supply Shock"}

D %>% #filter(GG.mppcr >1) %>% 
  group_by(price.city.tercile) %>%
  summarise(mean=gmodels::ci(shock10.pricec.city,na.rm=T)[1],
            lowCI=gmodels::ci(shock10.pricec.city, na.rm=T)[2],
            highCI=gmodels::ci(shock10.pricec.city, na.rm=T)[3],
            sd=gmodels::ci(shock10.pricec.city, na.rm=T)[4]) %>%
  ggplot(aes(x=price.city.tercile,y=mean)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI), position=position_dodge(width=.5)) +
  ylab("Cardinal Effect on Home Values")+
  ggtitle("Full Sample") +
  theme(legend.positio="bottom")

D %>% #filter(GG.mppcr >1) %>% 
  group_by(price.city.tercile, ownhome) %>%
  summarise(mean=gmodels::ci(shock10.pricec.city,na.rm=T)[1],
            lowCI=gmodels::ci(shock10.pricec.city, na.rm=T)[2],
            highCI=gmodels::ci(shock10.pricec.city, na.rm=T)[3],
            sd=gmodels::ci(shock10.pricec.city, na.rm=T)[4]) %>%
  ggplot(aes(x=price.city.tercile,y=mean,group=ownhome)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI, color=factor(ownhome)), position=position_dodge(width=.5)) +
  ylab("Cardinal Effect on Home Values")+
  ggtitle("Owners vs. Renters") +
  theme(legend.positio="bottom")

D %>% #filter(GG.mppcr >1) %>% 
  group_by(price.city.tercile, want.price2) %>%
  summarise(mean=gmodels::ci(shock10.pricec.city,na.rm=T)[1],
            lowCI=gmodels::ci(shock10.pricec.city, na.rm=T)[2],
            highCI=gmodels::ci(shock10.pricec.city, na.rm=T)[3],
            sd=gmodels::ci(shock10.pricec.city, na.rm=T)[4]) %>%
  ggplot(aes(x=price.city.tercile,y=mean,group=want.price2)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI, color=factor(want.price2)), position=position_dodge(width=.5)) +
  ylab("Cardinal Effect on Home Values")+
  ggtitle("Those Who Want Prices Lower vs. Higher") +
  theme(legend.positio="bottom")

```


We will also report results of a linear model of the outcome variables as a function of economic knowledge, modeled as follows. (Eval is turned off in the preanalysis plan for efficient knitting of the document.)

```{r results - shock10 models, eval=F}

# This can be coded more efficiently.

lmlist.shock10.all <- lmlist.shock10.owner <- lmlist.shock10.tenant <- lmlist.shock10.lower <- lmlist.shock10.notlower  <-list()

yvar <- c("shock10.rentc.city", "shock10.rento.city", "shock10.pricec.city", "shock10.priceo.city")

col.labels<-c("**Citywide Rent \n (cardinal)**", "**Citywide Rent \n (ordinal)**", "**Citywide Price \n (cardinal)**", "**Citywide Price \n (ordinal)**")

terms.0 <- "~ rent.city.tercile + know.PC1"

for(i in 1:length(yvar)){
 lmlist.shock10.all[[i]]<-D%>%
 lm(formula=as.formula(paste0(yvar[i], terms.0)), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.shock10.all,  tab_spanner = col.labels)

for(i in 1:length(yvar)){
 lmlist.shock10.owner[[i]]<-D%>%
 filter(ownhome == 1) %>%
 lm(formula=as.formula(paste0(yvar[i], terms.0)), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.shock10.owner,  tab_spanner = col.labels)

for(i in 1:length(yvar)){
 lmlist.shock10.tenant[[i]]<-D%>%
 filter(ownhome != 1) %>%
 lm(formula=as.formula(paste0(yvar[i], terms.0)), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.shock10.tenant,  tab_spanner = col.labels)

for(i in 1:length(yvar)){
 lmlist.shock10.notlower[[i]]<-D%>%
 filter(want.price2 == "Not_lower") %>%
 lm(formula=as.formula(paste0(yvar[i], terms.0)), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.shock10.notlower,  tab_spanner = col.labels)

for(i in 1:length(yvar)){
 lmlist.shock10.lower[[i]]<-D%>%
 filter(want.price2 == "Lower") %>%
 lm(formula=as.formula(paste0(yvar[i], terms.0)), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.shock10.lower,  tab_spanner = col.labels)


```


## Anticipated effect of new, expensive housing project on availability of affordable homes

We next examine chain-of-move beliefs (\$mast.afford, \$mast.low) among respondents in sample as a whole and in the target subgroups. This is about the mechanism through which a supply shock would lower prices. Responses to \$mast.afford should be highly correlated with responses to \$shock10.rentc.city and \$shock10.rento.city.

We repeat the above exploration of differences in means across housing markets and target subgroups. 


```{r results - mast - figs, fig.cap="Respondent Predictions for Chain-of-Moves Battery."}

D %>% #filter(GG.mppcr >1) %>% 
  group_by(price.city.tercile) %>%
  summarise(mean=gmodels::ci(mast.afford,na.rm=T)[1],
            lowCI=gmodels::ci(mast.afford, na.rm=T)[2],
            highCI=gmodels::ci(mast.afford, na.rm=T)[3],
            sd=gmodels::ci(mast.afford, na.rm=T)[4]) %>%
  ggplot(aes(x=price.city.tercile,y=mean)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI), position=position_dodge(width=.5)) +
  ylab("Prediction About Affordable Housing")+
  ggtitle("Full Sample") +
  theme(legend.positio="bottom")

D %>% #filter(GG.mppcr >1) %>% 
  group_by(price.city.tercile, ownhome) %>%
  summarise(mean=gmodels::ci(mast.afford,na.rm=T)[1],
            lowCI=gmodels::ci(mast.afford, na.rm=T)[2],
            highCI=gmodels::ci(mast.afford, na.rm=T)[3],
            sd=gmodels::ci(mast.afford, na.rm=T)[4]) %>%
  ggplot(aes(x=price.city.tercile,y=mean,group=ownhome)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI, color=factor(ownhome)), position=position_dodge(width=.5)) +
  ylab("Prediction About Affordable Housing")+
  ggtitle("Owners vs. Renters") +
  theme(legend.positio="bottom")

D %>% #filter(GG.mppcr >1) %>% 
  group_by(price.city.tercile, ownhome) %>%
  summarise(mean=gmodels::ci(mast.low,na.rm=T)[1],
            lowCI=gmodels::ci(mast.low, na.rm=T)[2],
            highCI=gmodels::ci(mast.low, na.rm=T)[3],
            sd=gmodels::ci(mast.low, na.rm=T)[4]) %>%
  ggplot(aes(x=price.city.tercile,y=mean,group=ownhome)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI, color=factor(ownhome)), position=position_dodge(width=.5)) +
  ylab("Prediction About Low Income Housing")+
  ggtitle("Owners vs. Renters") +
  theme(legend.positio="bottom")

```

We also report a linear model of the Mast predictions as a function of economic knowledge, both for the full sample and the target subgroups.

<!--This section is broken because the columns are labeled incorrectly.-->

```{r results - mast, eval=F}

lmlist.mast.all <- lmlist.mast.owner <- lmlist.mast.tenant <- lmlist.mast.lower <- lmlist.mast.notlower  <-list()

yvar <- c("mast.afford", "mast.low")

col.labels<-c("**Citywide Rent \n (cardinal)**", "**Citywide Rent \n (ordinal)**", "**Citywide Price \n (cardinal)**", "**Citywide Price \n (ordinal)**")

terms.0 <- "~ rent.city.tercile + know.PC1"

for(i in 1:length(yvar)){
 lmlist.mast.all[[i]]<-D%>%
 lm(formula=as.formula(paste0(yvar[i], terms.0)), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.mast.all,  tab_spanner = col.labels)

for(i in 1:length(yvar)){
 lmlist.mast.owner[[i]]<-D%>%
 filter(ownhome == 1) %>%
 lm(formula=as.formula(paste0(yvar[i], terms.0)), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.mast.owner,  tab_spanner = col.labels)

for(i in 1:length(yvar)){
 lmlist.mast.tenant[[i]]<-D%>%
 filter(ownhome != 1) %>%
 lm(formula=as.formula(paste0(yvar[i], terms.0)), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.mast.tenant,  tab_spanner = col.labels)

for(i in 1:length(yvar)){
 lmlist.mast.notlower[[i]]<-D%>%
 filter(want.price2 == "Not_lower") %>%
 lm(formula=as.formula(paste0(yvar[i], terms.0)), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.mast.notlower,  tab_spanner = col.labels)

for(i in 1:length(yvar)){
 lmlist.mast.lower[[i]]<-D%>%
 filter(want.price2 == "Lower") %>%
 lm(formula=as.formula(paste0(yvar[i], terms.0)), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.mast.lower,  tab_spanner = col.labels)


```

We expect the Mast predictions to be strongly negatively correlated with predicted rent and price effects from an exogenous 10% increase in the size of the region's housing stock. 

```{r results - mast and shock10 cor}

D%>%
  select(mast.afford, mast.low, shock10.rentc.city, shock10.rento.city, shock10.pricec.city, shock10.priceo.city, ownhome, want.price2, engage.PC1, free.PC1, know.PC1, loc.PC1) %>%
  sapply(., as.numeric)%>%
  correlate()%>%
  shave(upper = TRUE) %>%
  fashion(decimals = 2, na_print = "—") 

```


## Anticipated effect of rezoning, varying geographic scale

Our rezoning experiment manipulates geographic scale, and elicits quantity outcomes as well as price outcomes. We hypothesize that predicted effects on price and quantity will be increasing in (1) rents (\$rent.city.tercile), and (2) geographic scale (\$GD.treat). We expect the scale effect to manifest clearly in the local vs. citywide contrast. We have no hypothesis about whether it will manifest in the local vs. statewide contrast, since respondents may anticipate that state would be ineffectual in trying to make cities approve housing under state zoning rules. 


<!-- CE: This is where Hankinson's "When Do Renters Behave Like Homeowners" question comes to the fore, although we could rephrase it as, "When Do Renters Predict Like Homeowners?" Hankinson's thesis is that in high price cities, renters expect rent increases from rezoning for greater density if it's a neighborhood-level rezoning). We should do a figure in which mean($GD.rentc.nabe) is plotted for homeowners vs. renters, across each of the 5 \$rent.city quintiles, and for each version of the rezoning scenario (nabe, city, state). I'd be surprised if we see renter and homeowner predictions diverging in high-price zips, but who knows. 

SO 3-15: I wonder if this might be a little outside the scope of our first paper like we discussed the other day. I can however see this being an APSR short or a Research and Politics piece since it's an interesting extension of Michael's paper and we have the data right here. I just think it might lard up the paper for which we're preparing this PAP.

-->

### Treatment effect on quantity and price predictions


We report the difference of means for predicted effects on housing stock increase as well as effects on rental prices for each treatment condition, split across the average price tercile for each respondent city. Here is a representative figure. We will report analogous results for all four outcome variables (quantity, neighborhood rent, neighborhood home value, and citywide rent), and for the target splits of the data (\$ownhome, \$want.price2).


```{r results GD figs}

D %>% group_by(GD.treat, price.city.tercile) %>%
  summarise(mean=gmodels::ci(GD.quant,na.rm=T)[1],
            lowCI=gmodels::ci(GD.quant, na.rm=T)[2],
            highCI=gmodels::ci(GD.quant, na.rm=T)[3],
            sd=gmodels::ci(GD.quant, na.rm=T)[4]) %>%
  #pivot_longer(cols=c(mean, lowCI,highCI,sd)) %>%
  ggplot(aes(x=GD.treat,y=mean,group=price.city.tercile)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI, color=factor(price.city.tercile)),
                  position=position_dodge(width=.5)) +  
  ylab("Quantity Change Prediction")+
  theme(legend.positio="bottom")

D %>% group_by(GD.treat, price.city.tercile) %>%
  summarise(mean=gmodels::ci(GD.rentc.nabe,na.rm=T)[1],
            lowCI=gmodels::ci(GD.rentc.nabe, na.rm=T)[2],
            highCI=gmodels::ci(GD.rentc.nabe, na.rm=T)[3],
            sd=gmodels::ci(GD.rentc.nabe, na.rm=T)[4]) %>%
  #pivot_longer(cols=c(mean, lowCI,highCI,sd)) %>%
  ggplot(aes(x=GD.treat,y=mean,group=price.city.tercile)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI, color=factor(price.city.tercile)),
                  position=position_dodge(width=.5)) +  
  ylab("Neighborhood Rental Price Change Prediction")+
  theme(legend.positio="bottom")

```


We also introduce economic knowledge as a covariate. We expect the interactions between \$rent.city.tercile and \$know.PC1, and between \$GD.treat and \$know.PC1, to be positive. That is, the difference between high-knowledge and low-knowledge respondents will manifest in the high-price markets where rezoning is most likely to affect quantity and thus price. (Eval=F to speed knitting.)

```{r results GD econ, eval=F}

yvar <- c("GD.quant", "GD.rentc.nabe", "GD.pricec.nabe", "GD.rentc.city", "GD.rento.nabe", "GD.priceo.nabe", "GD.rento.city")  

col.labels<-c("**Quantity**", "**Rent Nabe \n (cardinal)**", "**Price Nabe \n (cardinal)**", "**Rent Citywide \n (cardinal)**", "**Rent Nabe \n (ordinal)**", "**Price Nabe \n (ordinal)**", "**Rent Citywide \n (ordinal)**")

terms.0 <- "~ GD.treat"
terms.1 <- "~ GD.treat + rent.city.tercile + GD.treat:rent.city.tercile"
terms.2 <- "~ GD.treat + know.PC1 + GD.treat:know.PC1"
terms.3 <- "~ GD.treat + rent.city.tercile + know.PC1 + GD.treat:rent.city.tercile + GD.treat:know.PC1 + GD.treat:rent.city.tercile:know.PC1"

terms <- list(terms.0, terms.1, terms.2, terms.3)

lmlist.GD.all <- lmlist.GD.owner <- lmlist.GD.tenant <- lmlist.GD.lower <- lapply(lmlist.GD.notlower<-vector(mode = 'list', length(terms)), function(x) x<-vector(mode='list', length(yvar)))

for(i in 1:length(terms)){
for(j in 1:length(yvar)){
 lmlist.GD.all[[i]][[j]]<-D%>%
 lm(formula=as.formula(paste0(yvar[j], terms[[i]])), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.GD.all[[i]],  tab_spanner = col.labels)
}

for(i in 1:length(terms)){
for(j in 1:length(yvar)){
 lmlist.GD.owner[[i]][[j]]<-D%>%
 filter(ownhome == 1) %>%
 lm(formula=as.formula(paste0(yvar[j], terms[[i]])), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.GD.all[[i]],  tab_spanner = col.labels)
}

for(i in 1:length(terms)){
for(j in 1:length(yvar)){
 lmlist.GD.tenant[[i]][[j]]<-D%>%
 filter(ownhome != 1) %>%
 lm(formula=as.formula(paste0(yvar[j], terms[[i]])), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.GD.all[[i]],  tab_spanner = col.labels)
}

for(i in 1:length(terms)){
for(j in 1:length(yvar)){
 lmlist.GD.notlower[[i]][[j]]<-D%>%
 filter(want.price2 == "Not_lower") %>%
 lm(formula=as.formula(paste0(yvar[j], terms[[i]])), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.GD.all[[i]],  tab_spanner = col.labels)
}

for(i in 1:length(terms)){
for(j in 1:length(yvar)){
 lmlist.GD.lower[[i]][[j]]<-D%>%
 filter(want.price2 == "Lower") %>%
 lm(formula=as.formula(paste0(yvar[j], terms[[i]])), data=.)%>%
 tbl_regression(intercept=TRUE)
}
tbl_merge(lmlist.GD.all[[i]],  tab_spanner = col.labels)
}

```


### Treatment effect on tail risk for homeowners (\$GD.angst.price) and renters (\$GD.angst.rent)

Hypothesis: Tail risk is increasing in geographic scale of reform for homeowners, decreasing in geographic scale for renters.

Results, subset by housing-market tercile.

```{r tail_risk}

D <- D %>% mutate(general_angst = ifelse(is.na(GD.angst.price), GD.angst.rent,GD.angst.price))

D %>% #filter(GG.mppcr >1) %>% 
  group_by(GD.treat, ownhome) %>%
  summarise(mean=gmodels::ci(general_angst,na.rm=T)[1],
            lowCI=gmodels::ci(general_angst, na.rm=T)[2],
            highCI=gmodels::ci(general_angst, na.rm=T)[3],
            sd=gmodels::ci(general_angst, na.rm=T)[4]) %>%
  #pivot_longer(cols=c(mean, lowCI,highCI,sd)) %>%
  ggplot(aes(x=GD.treat,y=mean,group=ownhome)) + 
  geom_point(aes(color=factor(ownhome))) +
  geom_pointrange(aes(ymin=lowCI,ymax=highCI, color=factor(ownhome))) +
  facet_grid(.~ownhome) +
  theme(legend.positio="bottom")


```



### Does quantity skepticism explain price skepticism?

Pooling across all rezoning conditions, we investigate the correlation between perceived effect of rezoning on regional quantity of housing (\$GD.quant) and perceived effect on citywide rents (\$GD.rento.city, $GD.rentc.city).  Pictured below are differences in means for predicted effects on quanity and city-wide rents. 


<!-- ```{r results-pooling} -->

<!-- # quant <- D %>% lm_robust(GD.quant ~ GD.treat, data=., se_type = "stata", clusters=GD.treat) %>% -->
<!-- #   tbl_regression(intercept=T)  -->

<!-- D %>% group_by(GD.treat, price.city.tercile) %>% -->
<!--   summarise(mean=gmodels::ci(GD.quant,na.rm=T)[1], -->
<!--             lowCI=gmodels::ci(GD.quant, na.rm=T)[2], -->
<!--             highCI=gmodels::ci(GD.quant, na.rm=T)[3], -->
<!--             sd=gmodels::ci(GD.quant, na.rm=T)[4]) %>% -->
<!--   ggplot(aes(x=GD.treat,y=mean, color=factor(price.city.tercile))) +  -->
<!--   geom_pointrange(aes(ymin=lowCI,ymax=highCI), position = position_dodge(width=.5)) + -->
<!--   ggtitle("Quantity") + -->
<!--   ylab("Perceived Effect of Rezoning") + -->
<!--   theme(legend.positio="bottom") -->

<!-- # rento_city <- D %>% lm_robust(GD.rento.city ~ GD.treat, data=., se_type = "stata", clusters=GD.treat) %>% -->
<!-- #   tbl_regression(intercept=T) -->

<!-- D %>% group_by(GD.treat, price.city.tercile) %>% -->
<!--   summarise(mean=gmodels::ci(GD.rentc.city,na.rm=T)[1], -->
<!--             lowCI=gmodels::ci(GD.rentc.city, na.rm=T)[2], -->
<!--             highCI=gmodels::ci(GD.rentc.city, na.rm=T)[3], -->
<!--             sd=gmodels::ci(GD.rentc.city, na.rm=T)[4]) %>% -->
<!--   ggplot(aes(x=GD.treat,y=mean, color=factor(price.city.tercile))) +  -->
<!--   geom_pointrange(aes(ymin=lowCI,ymax=highCI), position = position_dodge(width=.5)) + -->
<!--   ggtitle("City Rent Price") + -->
<!--   ylab("Perceived Effect of Rezoning") + -->
<!--   theme(legend.positio="bottom") -->


<!-- #  -->
<!-- # rentc_city <- D %>% lm_robust(GD.rento.city ~ GD.treat, data=., se_type = "stata", clusters=GD.treat) %>% -->
<!-- #   tbl_regression(intercept=T) -->
<!-- #  -->
<!-- # tab <- tbl_merge(list(quant, rento_city, rentc_city), tab_spanner=c("Quantity","Ordinal Rent Change","Percentage Rent Change"))  -->

<!-- ``` -->


```{r results - price on quantity}

quant <- D %>% lm_robust(GD.quant ~ GD.treat, data=., se_type = "stata", clusters=GD.treat) %>%
  tbl_regression(intercept=T) 

rento_city <- D %>% lm_robust(GD.rento.city ~ GD.treat, data=., se_type = "stata", clusters=GD.treat) %>%
  tbl_regression(intercept=T)

rentc_city <- D %>% lm_robust(GD.rentc.city ~ GD.treat, data=., se_type = "stata", clusters=GD.treat) %>%
  tbl_regression(intercept=T)

tab <- tbl_merge(list(quant, rento_city, rentc_city), tab_spanner=c("Quantity","Ordinal Rent Change","Percentage Rent Change")) 

```



### Do predicted price and rent effects explains support?

We pool across the rezoning geographic scales and model support for "gentle density" rezoning as a function of economic knowledge, support for free-market policies in other domains, liberal-conservative ideology, and our measure of localist ideology. We report results for the sample as a whole and the target subgroups.    


```{r results GD support fig}

D %>% group_by(price.city.tercile) %>%
  summarise(mean=gmodels::ci(GD.support,na.rm=T)[1],
            lowCI=gmodels::ci(GD.support, na.rm=T)[2],
            highCI=gmodels::ci(GD.support, na.rm=T)[3],
            sd=gmodels::ci(GD.support, na.rm=T)[4]) %>%
  ggplot(aes(x=price.city.tercile,y=mean)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI), position = position_dodge(width=.5)) +
  ylab("Support for Gentle Density")


```


```{r results GD support models, eval=F}

yvar <- "GD.support"

col.labels<-"**Support**"

# CE: should we add $educ to these models? 

# Models 0-2. A key question is whether knowledge & rent.tercile interacts in the expected ways for renters & homeowners.

terms.0 <- "~ rent.city.tercile + know.PC1 + free.PC1 + loc.PC1 + ideo.PC1"
terms.1 <- "~ rent.city.tercile + know.PC1 + free.PC1 + loc.PC1 + ideo.PC1"
terms.2 <- "~ rent.city.tercile + know.PC1 + know.PC1:rent.city.tercile + free.PC1 + loc.PC1 + ideo.PC1"

# Models 3-4 use price and rent predictions rather than objective attributes of city and knowledge. (I am not including rent city b/c of concern about collinearity with rent nabe)
terms.3 <- "~ GD.rentc.nabe + GD.pricec.nabe + free.PC1 + ideo.PC1 + loc.PC1"
terms.4 <- "~ GD.rento.nabe + GD.priceo.nabe + free.PC1 + ideo.PC1 + loc.PC1"

terms <- list(terms.0, terms.1, terms.2, terms.3, terms.4)

lmlist.GDsupport.all <- lmlist.GDsupport.owner <- lmlist.GDsupport.tenant <- lmlist.GDsupport.lower <- lapply(lmlist.GDsupport.notlower<-vector(mode = 'list', length(terms)), function(x) x<-vector(mode='list', length(yvar)))

for(i in 1:length(terms)){
for(j in 1:length(yvar)){
 lmlist.GDsupport.all[[i]][[j]]<-D%>%
 lm_robust(formula=as.formula(paste0(yvar[j], terms[[i]])), data=., se_type="stata", clusters=GD.treat)%>%
 tbl_regression(intercept=TRUE)
}
}

for(i in 1:length(terms)){
for(j in 1:length(yvar)){
 lmlist.GDsupport.owner[[i]][[j]]<-D%>%
 filter(ownhome == 1) %>% 
 lm_robust(formula=as.formula(paste0(yvar[j], terms[[i]])), data=., se_type="stata", clusters=GD.treat)%>%
 tbl_regression(intercept=TRUE)
}
}

for(i in 1:length(terms)){
for(j in 1:length(yvar)){
 lmlist.GDsupport.tenant[[i]][[j]]<-D%>%
 filter(ownhome != 1) %>% 
 lm_robust(formula=as.formula(paste0(yvar[j], terms[[i]])), data=., se_type="stata", clusters=GD.treat)%>%
 tbl_regression(intercept=TRUE)
}
}

for(i in 1:length(terms)){
for(j in 1:length(yvar)){
 lmlist.GDsupport.notlower[[i]][[j]]<-D%>%
 filter(want.price2 == "Not_lower") %>% 
 lm_robust(formula=as.formula(paste0(yvar[j], terms[[i]])), data=., se_type="stata", clusters=GD.treat)%>%
 tbl_regression(intercept=TRUE)
}
}

for(i in 1:length(terms)){
for(j in 1:length(yvar)){
 lmlist.GDsupport.lower[[i]][[j]]<-D%>%
 filter(want.price2 == "Lower") %>% 
 lm_robust(formula=as.formula(paste0(yvar[j], terms[[i]])), data=., se_type="stata", clusters=GD.treat)%>%
 tbl_regression(intercept=TRUE)
}
}

```


### Does perceived tail risk explain support?

In our last models of support, we substitute perceptions of the risk of large, adverse shock to one's own home value (for owners) or the rental value of one's home (for renters) for perceived price and rent effects at the neighborhood level. This is in the spirit of Fischel, who famously posited that homeowners' opposition to rezoning is grounded in risk aversion.


```{r results GD tail risk figs}

D %>% group_by(price.city.tercile, ownhome) %>%
  summarise(mean=gmodels::ci(GD.support,na.rm=T)[1],
            lowCI=gmodels::ci(GD.support, na.rm=T)[2],
            highCI=gmodels::ci(GD.support, na.rm=T)[3],
            sd=gmodels::ci(GD.support, na.rm=T)[4]) %>%
  ggplot(aes(x=price.city.tercile,y=mean, group=ownhome)) + 
  geom_pointrange(aes(ymin=lowCI,ymax=highCI, color=factor(ownhome)), position = position_dodge(width=.5)) +
  ylab("Support for Gentle Density") +
  theme(legend.position="bottom")



```


```{r results GD tail risk, eval=F}

lmlist.GDsupportangst <- list()

lmlist.GDsupportangst$owner <-  D %>%
 filter(ownhome == 1) %>% 
 lm_robust(GD.support ~ GD.angst.price + free.PC1 + ideo.PC1 + loc.PC1, data=., se_type="stata", clusters=GD.treat)%>%
  tbl_regression()

lmlist.GDsupportangst$tenant <-  D %>%
 filter(ownhome != 1) %>% 
 lm_robust(GD.support ~ GD.angst.rent + free.PC1 + ideo.PC1 + loc.PC1, data=., se_type="stata", clusters=GD.treat)%>%
  tbl_regression()

tbl_merge(lmlist.GDsupportangst, tab_spanner = c("Owners", "Tenants"))
```






